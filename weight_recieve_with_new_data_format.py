import time
import numpy as np
import matplotlib.pyplot as plt
import serial
# import joblib
# ==============================
# predicition fucntion
# ==============================

def calculate_ft_from_psoc(c1n, c2n, c3n, c4n, c1s, c2s, c3s, c4s):
    """
    Calculate force/torque from 8 PSOC sensor inputs using 2nd-order polynomial regression.
    
    Args:
        c1n, c2n, c3n, c4n: Normal sensors 1-4
        c1s, c2s, c3s, c4s: Shear sensors 1-4
    
    Returns:
        np.array: [fx, fy, fz, tx, ty, tz]
    """
    # Model intercepts
    fx_intercept = -6.018745857180133e+04
    fy_intercept = -2.016358749653060e+04
    fz_intercept = 4.119084927626266e+05
    tx_intercept = -8.804094328781720e+02
    ty_intercept = -3.610360020036960e+03
    tz_intercept = -1.284116167795461e+03
    
    # Model coefficients (45 polynomial features each)
    fx_coef = np.array([
        3.046183461811196e-07, 3.915173383998768e-01, 4.919275893827008e-01, 1.814119519290021e-01, -7.229482869826916e-03,
        -1.815187667211892e+00, 2.737244577593229e-01, -5.299132964183279e-01, 7.292742457467025e-01, -9.316079116213718e-07,
        -1.193962417393207e-06, 2.899563027464515e-07, -7.104908265670494e-07, -4.125882053836821e-06, 8.630924856239760e-06,
        -8.098849493079892e-07, -2.726979417031757e-07, -9.651046054970302e-07, -1.972049379164448e-06, 8.353310119090770e-07,
        2.061693232475170e-05, -8.520498953079890e-06, 6.026333615585179e-06, -6.264458969068996e-06, 3.357637251991820e-08,
        4.841650995539879e-09, 1.811811198130478e-06, -1.651376821184664e-06, -8.363604970461565e-08, -2.038558066286701e-07,
        -3.605777446928149e-08, -2.547238739457244e-06, -3.996451030635204e-07, -3.246504029687930e-07, 2.085980041442725e-07,
        -8.449646923320912e-05, 1.523224007034791e-04, -2.466142579634608e-06, 3.841388038828940e-06, -5.336576390777548e-05,
        2.556574141098938e-05, -1.559162681015491e-05, -1.472358612444457e-07, -4.181690015372049e-06, 2.464001289340253e-07
    ])
    
    fy_coef = np.array([
        2.305747385103482e-06, 1.953131646367295e-02, 2.351761635323825e-01, 7.055264424244227e-02, -2.410359779319578e-02,
        -1.290470723448289e+01, 1.831255948179031e+00, 3.597199040086411e-01, 2.104849843515600e-02, 1.789072397937231e-06,
        -3.351424380391913e-06, -2.642811608213860e-07, 4.307992367794790e-09, 4.720446561064268e-05, -2.314063021280515e-05,
        3.854105250577850e-07, -6.638678520281561e-08, 9.074885014118278e-07, -2.724612216118482e-07, 1.330267822029424e-07,
        7.942752050579357e-05, 6.214106582463861e-06, -3.847529715772655e-06, 5.445278490060610e-08, -4.984217116595596e-08,
        5.696535050084853e-09, -6.485446140649453e-07, -2.908226671568743e-06, 3.327869933189137e-08, 7.046780960429125e-08,
        2.707795059284621e-08, -7.245507395893706e-06, 6.691026335555519e-06, 2.551868796451173e-07, -1.458136687667016e-07,
        4.143664070974546e-04, 2.217680635370080e-04, 7.912205019038958e-07, 1.285855254785846e-05, 4.006875565684273e-04,
        1.607398805464470e-05, 1.112492860243909e-05, 2.322774736458535e-07, 2.838201319897904e-06, 3.061783690315489e-07
    ])
    
    fz_coef = np.array([
        1.891128009663307e-05, -7.398897508170579e-01, -8.370138753089616e+00, 7.612665051483160e-01, 3.384519456483315e-01,
        -1.158865106260597e+02, -2.076698839480769e+01, 4.635287877579364e+00, 1.146128747175233e+00, 2.667024544031708e-05,
        -4.232881988709222e-05, 5.093109722689916e-07, -4.370616155286890e-06, 3.893508421053627e-04, -4.035757564230536e-04,
        -1.359991746780754e-06, 3.844288954687172e-06, 6.293251549453809e-05, -5.757012885508842e-06, 2.126815445737850e-06,
        6.872152567925470e-04, 5.786121158844332e-04, -4.314453732077377e-05, -1.341498491952303e-05, -6.708039686777743e-07,
        1.936785130136236e-09, 1.232303359146689e-05, -2.607411341832136e-06, 8.854833393550917e-07, -2.506179905827060e-06,
        -3.845060265021305e-07, -4.222097488303497e-05, 4.190176365140747e-05, 2.726376892183899e-06, 2.054995073117252e-06,
        2.149951035012723e-03, -1.392477546453137e-04, 6.429858751689370e-05, 3.991665376572134e-05, 5.554807207420643e-03,
        8.531747539336935e-05, 5.005584877873215e-05, 3.321188835297690e-06, -1.005078506374844e-06, -1.029682398077816e-06
    ])
    
    tx_coef = np.array([
        1.498639606169316e-07, -4.710875444588795e-02, 4.960105440245996e-02, 3.114757774792658e-03, 4.906874153724602e-03,
        -9.123405020614327e-01, -1.046435418353015e-01, 7.507823714662149e-03, 2.557828177118919e-02, 1.653356987237570e-07,
        1.511084705400859e-07, 8.542632098401105e-11, -5.178641984211277e-08, 2.341936626689094e-06, 6.281653872869586e-07,
        -2.490999532565620e-08, -4.604481476278166e-08, -2.658905373188212e-07, -2.775735156993019e-08, 4.037218061973281e-09,
        6.258669087490402e-06, 3.554908696040742e-07, -4.817775551612330e-08, -1.789304653498495e-07, -7.260202999878166e-12,
        -4.576213941790639e-12, -3.953057348819909e-08, 5.950300794767322e-08, 6.924015349954611e-09, 7.643916437059503e-09,
        1.365979193921765e-09, -2.496769964580067e-07, -1.331575497528635e-07, 3.789912036544080e-10, -8.530773604772772e-09,
        1.859731144116051e-05, 1.765428693566919e-05, -1.269884947950147e-07, 9.113083562144250e-07, -1.626973316533636e-05,
        6.002256323037710e-07, -6.657513344545699e-08, -6.613249751564034e-09, -1.996142838061263e-08, 7.870376024096887e-08
    ])
    
    ty_coef = np.array([
        -3.054778366279614e-08, 4.080036379369498e-03, 6.455896773566308e-02, -2.519378718476815e-03, 5.213285370174100e-04,
        2.999187441123031e-01, 4.016832552392534e-01, -2.914926456904444e-02, -2.987518490389711e-02, -5.740116449140549e-08,
        5.304509247214480e-08, 3.027554925698434e-09, 1.789495512020792e-08, -7.503287142635383e-07, -2.510296624663333e-07,
        -3.601986388677124e-08, -1.738841893467529e-08, -3.186965314261205e-07, 1.233538764085252e-08, -2.101609469150504e-08,
        -2.258399732321251e-06, -3.659915082183491e-06, 2.952074074910654e-07, 2.749275716515098e-07, 3.717719337133480e-09,
        -4.775597276627664e-10, 2.428458525008034e-08, 1.139677792071488e-07, -2.313360619990048e-09, -1.365474823361054e-08,
        -1.844826073537721e-11, 1.803718055771793e-07, 9.504777107236968e-08, -4.282003749625160e-09, 2.309002059161741e-08,
        -1.116614856523486e-05, -1.524053529297285e-05, -1.382577649195799e-06, -5.535077068238972e-07, -1.112444861876622e-05,
        -5.092935812181505e-07, 1.166935918947252e-06, -8.222909739007627e-09, -1.667156771427134e-07, -5.498869872222876e-08
    ])
    
    tz_coef = np.array([
        3.782240326022936e-09, 1.023246771070913e-02, 1.174522024606123e-02, 2.776361865601717e-03, -2.239223780277097e-03,
        -3.233282603388142e-02, -2.151158198875897e-02, 3.964280497141005e-03, 1.399370052095758e-02, -1.360586430086911e-08,
        -5.666740246673933e-08, -3.634753168883648e-09, -1.926432889335388e-09, 2.208589143593105e-07, 1.322281520912465e-07,
        -1.703753317445633e-08, -1.002197751552945e-08, -2.258238229456140e-08, -2.095371516628655e-08, 2.029986876745389e-08,
        1.598311972375765e-07, 1.223260345829473e-07, -1.165313089531985e-08, -1.122350299006446e-07, -3.741056061869217e-10,
        5.811456577373002e-10, -3.084835668211150e-08, -1.788961469170995e-08, -1.256666332523641e-09, -4.354701869684359e-09,
        2.910469456058472e-10, -4.845806378025476e-08, -2.880062185697404e-09, -2.769837564902322e-09, 1.227836197217067e-09,
        1.880734618659632e-06, -7.866807046982829e-07, -3.355827279473546e-08, -5.830128797156929e-09, 6.935305231410458e-06,
        6.284663464574027e-07, -4.714055740438685e-07, -4.553248902169446e-09, -7.586507373878195e-08, -1.831791662572408e-09
    ])
    
    # Create input array
    input_arr = np.array([c1n, c2n, c3n, c4n, c1s, c2s, c3s, c4s])
    
    # Calculate polynomial features (degree 2)
    poly_features = [1.0]  # Constant term
    
    # Linear terms (8 features)
    poly_features.extend(input_arr)
    
    # Quadratic and interaction terms (36 features)
    for i in range(8):
        for j in range(i, 8):
            poly_features.append(input_arr[i] * input_arr[j])
    
    poly_features = np.array(poly_features)
    
    # Calculate predictions
    fx = fx_intercept + np.dot(fx_coef, poly_features)
    fy = fy_intercept + np.dot(fy_coef, poly_features)
    fz = fz_intercept + np.dot(fz_coef, poly_features)
    tx = tx_intercept + np.dot(tx_coef, poly_features)
    ty = ty_intercept + np.dot(ty_coef, poly_features)
    tz = tz_intercept + np.dot(tz_coef, poly_features)
    
    return np.array([fx, fy, fz, tx, ty, tz])




# ==============================
# Derivative shit that hopes the sensativity of the sensor is consistent
# ==============================
# Previous capacitance values for derivative calculation
global C_init
global first_run


NUM_SENSORS = 8
C_init = np.zeros(NUM_SENSORS)   # ensure length matches NUM_SENSORS
first_run = True

max_points = 100  # how many points to show on plot

# ==============================
# Sensor Weights
# ==============================
# Adjust these numbers to scale each sensor's contribution
sensor_weights = np.array([
    [3.046183461811196e-07, 3.915173383998768e-01, 4.919275893827008e-01, 1.814119519290021e-01, -7.229482869826916e-03, -1.815187667211892e+00, 2.737244577593229e-01, -5.299132964183279e-01],
    [2.305747385103482e-06, 1.953131646367295e-02, 2.351761635323825e-01, 7.055264424244227e-02, -2.410359779319578e-02, -1.290470723448289e+01, 1.831255948179031e+00, 3.597199040086411e-01],
    [1.891128009663307e-05, -7.398897508170579e-01, -8.370138753089616e+00, 7.612665051483160e-01, 3.384519456483315e-01, -1.158865106260597e+02, -2.076698839480769e+01, 4.635287877579364e+00],
    [1.498639606169316e-07, -4.710875444588795e-02, 4.960105440245996e-02, 3.114757774792658e-03, 4.906874153724602e-03, -9.123405020614327e-01, -1.046435418353015e-01, 7.507823714662149e-03],
    [-3.054778366279614e-08, 4.080036379369498e-03, 6.455896773566308e-02, -2.519378718476815e-03, 5.213285370174100e-04, 2.999187441123031e-01, 4.016832552392534e-01, -2.914926456904444e-02],
    [3.782240326022936e-09, 1.023246771070913e-02, 1.174522024606123e-02, 2.776361865601717e-03, -2.239223780277097e-03, -3.233282603388142e-02, -2.151158198875897e-02, 3.964280497141005e-03],
])

sensor_biases = np.array([
    -6.018745857180133e+04,  # fx_intercept
    -2.016358749653060e+04,  # fy_intercept
    4.119084927626266e+05,   # fz_intercept
    -8.804094328781720e+02,  # tx_intercept
    -3.610360020036960e+03,  # ty_intercept
    -1.284116167795461e+03   # tz_intercept
])
print(f"Using fixed sensor weights: {sensor_weights}")

# ==============================
# Ask user whether to use regression
# ==============================
use_model_input = input("Use calibration model? (y/n): ").strip().lower()
use_model = use_model_input == 'y'

# ==============================
# Load models if needed
# ==============================
if use_model:
    # normal_model = joblib.load("normal_data_linear_model.pkl")
    # shear_model = joblib.load("shear_data_linear_model.pkl")
    print("Loaded Normal and Shear models.")

# ==============================
# Setup serial connection
# ==============================
class FakeSerial:
    def __init__(self):
        self.counter = 0
    def readline(self):
        mode = self.counter % 2
        values = np.random.randint(1, 100, NUM_SENSORS)
        self.counter += 1
        time.sleep(0.1)
        return (f"{mode}," + ",".join(map(str, values)) + "\n").encode("utf-8")

try:
    ser = serial.Serial("COM7", 115200, timeout=1)
except:
    print("Using FakeSerial() for testing")
    ser = FakeSerial()

# ==============================
# Setup plot
# ==============================
plt.ion()
fig, ax = plt.subplots()

# Set y-limits based on mode
if use_model:
    ax.set_ylim(-10000, 10000)       # calibrated FT values
else:
    ax.set_ylim(-400, 400) # raw capacitance values

ax.set_xlim(0, max_points)
ax.set_xlabel("Sample")
ax.set_ylabel("Force / Torque / Capacitance")

# Choose plot keys (make these depend on NUM_SENSORS)
if use_model:
    plot_keys = ["Fx", "Fy", "Fz", "Tx", "Ty", "Tz"]
else:
    # For 8 sensors keep previous naming, otherwise generate generic names
    if NUM_SENSORS == 8:
        plot_keys = ["C1", "C2", "C3", "C4", "S1", "S2", "S3", "S4"]
    else:
        plot_keys = [f"C{i+1}" for i in range(NUM_SENSORS)]

lines = {}
for key in plot_keys:
    lines[key] = ax.plot([], [], label=key)[0]
ax.legend()
history = {key: [] for key in plot_keys}

# ==============================
# Main loop
# ==============================
try:
    while True:
        line = ser.readline().decode("utf-8").strip()
        if not line:
            continue

        try:
            parts = line.split(",")
            vals = list(map(float, parts[1:]))  # Skip first element
            if len(vals) != NUM_SENSORS:
                # skip malformed lines
                continue
            C = np.array(vals)
            if first_run:
                C_init = C.copy()
                first_run = False
        except:
            continue

        # Determine data to plot
        if use_model:
            # pred = normal_model.predict(C)
            # data = np.array(pred[0])  # expect length 6
            ft_values = calculate_ft_from_psoc(*C)
            data = ft_values
        else:
            # raw capacitance delta -> length NUM_SENSORS
            data = (C - C_init) * np.array([0, 0, 0, 0, 1, 1, 1, 1])
            # data = (C - C_init)

        # Update history safely (handle mismatched lengths)
        n_plot = len(plot_keys)
        n_data = len(data)
        for i, key in enumerate(plot_keys):
            if i < n_data:
                history[key].append(data[i])
            else:
                # no corresponding data channel; append 0 so plot lines stay aligned
                history[key].append(0.0)
            if len(history[key]) > max_points:
                history[key].pop(0)

        # Update plot
        for key in plot_keys:
            lines[key].set_data(range(len(history[key])), history[key])
        # lines["Fx"].set_data(range(len(history["Fx"])), history["Fx"])
        ax.set_xlim(0, max(len(history[plot_keys[0]]), max_points))
        plt.pause(0.01)

except KeyboardInterrupt:
    print("\nStopped real-time visualization")
